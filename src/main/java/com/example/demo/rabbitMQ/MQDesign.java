package com.example.demo.rabbitMQ;

public class MQDesign {
    /**
     *
     *
     * 本地消息表
     *
     * 生产：
     * 1. 本地事务+消息表方案
     * 这种方案通过数据库中的一张消息表来协调数据库事务和消息发送。
     *
     * 流程：
     * 在业务逻辑执行的数据库事务中，将业务数据和消息记录同时插入数据库。
     * 事务提交后，异步任务读取消息表中的未发送消息，发送到 RabbitMQ。
     * 消息发送成功后，标记消息状态为已发送。
     * 优点：
     * 简单且可靠。
     * 数据库的事务能力保证了消息和业务数据的强一致性。
     * 缺点：
     * 消息表可能带来额外的性能开销。
     * 需要额外开发消息表的处理逻辑。
     *
     *
     *
     *
     * 3. RabbitMQ Confirm 模式 + 事务最终一致性
     * 利用 RabbitMQ 的确认模式 (Publisher Confirms) 来保证消息的可靠发送。
     *
     * 流程：
     * 开启 RabbitMQ 的发布确认模式。
     * 业务数据库事务提交后，发送消息到 RabbitMQ。
     * 使用 RabbitMQ 确认机制，确保消息已被 RabbitMQ 接收。
     * 若 RabbitMQ 确认失败，可以通过重试机制重新发送消息。
     * 优点：
     * 性能比事务模式高。
     * RabbitMQ 确认机制保证消息的可靠性。
     * 缺点：
     * 业务逻辑稍微复杂，需要处理 RabbitMQ 的确认回调。
     *
     *
     *
     * 5. Outbox 模式
     * 将需要发送的消息放入一个 Outbox 表（业务数据库的一部分），然后使用一个独立的服务来轮询表中的消息并发送到 RabbitMQ。
     *
     * 流程：
     * 在数据库事务中写入业务数据和待发送消息（到 Outbox 表）。
     * 数据库事务提交后，独立的消息轮询服务将消息从 Outbox 表发送到 RabbitMQ。
     * 消息发送成功后，标记该消息为已处理。
     * 优点：
     * 结合业务逻辑，事务一致性强。
     * 易于实现与维护。
     * 缺点：
     * 消息轮询会带来一定的性能开销。
     *
     *
     *
     * 建议
     * 高一致性需求：推荐使用 本地事务+消息表 或 Outbox 模式。
     * 高性能需求：推荐使用 RabbitMQ Confirm 模式。
     * 复杂分布式事务场景：推荐使用 分布式事务框架（如 Seata）。
     *
     *
     *
     *
     * 消费：
     *
     * 1、消费事务更新消息表消费成功。
     * 2、消费成功事务回调中调用rabbitmq ack
     * 3、定时任务处理生产成功、消费成功的消息ack 和 2中的ack 加锁竞争
     *
     *
     */
}
